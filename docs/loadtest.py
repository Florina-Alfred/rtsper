#!/usr/bin/env python3
"""
Small helper that uses the system ffmpeg and ffplay to publish a local
video file to an RTSP topic and (optionally) play it back. Intended as a
minimal starting point for building a loadtest script.

Usage examples:
  ./docs/loadtest.py                           # publish docs/test_footage.mp4 to topic1 on localhost
  ./docs/loadtest.py --topic camera42 --play    # also run ffplay to view the stream (subscribe port)

This script is intentionally small and depends on the `ffmpeg` and
`ffplay` executables being on PATH.
"""
from __future__ import annotations

import argparse
import os
import shutil
import signal
import subprocess
import sys
import time


def find_exe(name: str) -> str:
    p = shutil.which(name)
    if not p:
        raise SystemExit(f"{name} not found in PATH; please install ffmpeg")
    return p


def build_ffmpeg_cmd(ffmpeg: str, infile: str, rtsp_url: str, reencode: bool, loop: bool) -> list:
    cmd = [ffmpeg]
    # read input at natural rate
    cmd += ["-re"]
    if loop:
        # loop infinitely
        cmd += ["-stream_loop", "-1"]
    cmd += ["-i", infile]
    if reencode:
        # re-encode to H.264/AAC which is generally accepted by RTSP servers
        cmd += [
            "-c:v",
            "libx264",
            "-preset",
            "veryfast",
            "-tune",
            "zerolatency",
            "-c:a",
            "aac",
        ]
    else:
        # try copy by default (fast, no CPU overhead)
        cmd += ["-c", "copy"]
    cmd += ["-f", "rtsp", rtsp_url]
    return cmd


def build_ffplay_cmd(ffplay: str, rtsp_url: str) -> list:
    # use TCP transport for reliability
    return [ffplay, "-rtsp_transport", "tcp", rtsp_url]


def build_subscriber_cmd(ffmpeg: str, rtsp_url: str) -> list:
    # Use ffmpeg as a lightweight subscriber that reads the RTSP stream and
    # discards output. This is generally lighter than ffplay and scriptable.
    # Use TCP transport for reliability.
    return [ffmpeg, "-rtsp_transport", "tcp", "-i", rtsp_url, "-f", "null", "-"]


def main() -> None:
    parser = argparse.ArgumentParser(description="Publish docs/test_footage.mp4 with ffmpeg")
    parser.add_argument("--host", default="127.0.0.1", help="RTSP server host to publish to")
    parser.add_argument("--pub-port", type=int, default=9191, help="RTSP publisher port")
    parser.add_argument("--sub-port", type=int, default=9192, help="RTSP subscriber port used by ffplay")
    parser.add_argument("--file", default=None, help="Video file to stream (defaults to docs/test_footage.mp4)")
    parser.add_argument("--reencode", action="store_true", help="Force re-encoding (libx264/aac) instead of -c copy")
    parser.add_argument("--no-loop", dest="loop", action="store_false", help="Do not loop the input file")
    parser.add_argument("--play", action="store_true", help="Also start ffplay to subscribe and view the stream")
    # topic generation options
    parser.add_argument("--topic", default=None, help="Specific topic name to publish to (mutually exclusive with --auto-topics and --topic-map)")
    parser.add_argument("--auto-topics", type=int, default=0, help="Autogenerate N topics named <prefix>1..<prefix>N")
    parser.add_argument("--topic-prefix", default="topic", help="Prefix for autogenerated topics")
    parser.add_argument("--topic-map", default=None, help="Explicit topic->subscriber mapping as JSON or comma list (eg 'topic1:3,topic2:2')")
    parser.add_argument("--spawn", action="store_true", help="Spawn one ffmpeg publisher per topic generated")
    parser.add_argument("--stagger-ms", type=int, default=200, help="Milliseconds to wait between spawning publishers when --spawn is used")
    parser.add_argument("--streams", type=int, default=0, help="Number of publisher streams to spawn (creates that many topics)")
    parser.add_argument("--receivers-per-topic", type=int, default=0, help="Number of receiver clients to spawn per topic")
    parser.add_argument("--save-logs", action="store_true", help="Save per-process logs to loadtest-logs/ (default: discard logs)")
    args = parser.parse_args()

    script_dir = os.path.dirname(os.path.realpath(__file__))
    default_file = os.path.join(script_dir, "test_footage.mp4")
    infile = args.file or default_file
    if not os.path.exists(infile):
        print(f"input file not found: {infile}")
        sys.exit(2)

    ffmpeg = find_exe("ffmpeg")
    ffplay = None
    if args.play:
        ffplay = find_exe("ffplay")

    # Build topic map according to provided flags. The result is a dict
    # mapping topic name -> desired subscriber count (int). This can be
    # used later to decide how many subscribers to spawn per topic.
    topic_map = {}
    if args.topic_map:
        # try JSON first
        try:
            import json

            topic_map = json.loads(args.topic_map)
            if not isinstance(topic_map, dict):
                raise ValueError("topic-map JSON must be an object")
            # ensure int values
            topic_map = {k: int(v) for k, v in topic_map.items()}
        except Exception:
            # fallback to comma-separated list like: topic1:3,topic2:2
            items = [s for s in args.topic_map.split(",") if s]
            for it in items:
                if ":" in it:
                    k, v = it.split(":", 1)
                    topic_map[k.strip()] = int(v)
                else:
                    topic_map[it.strip()] = 0
    elif args.auto_topics > 0:
        for i in range(1, args.auto_topics + 1):
            name = f"{args.topic_prefix}{i}"
            topic_map[name] = 0
    elif args.topic:
        topic_map[args.topic] = 0
    else:
        # default single topic
        topic_map["topic1"] = 0

    # if --streams provided, generate that many topics (overrides auto-topics)
    if args.streams > 0:
        topic_map = {f"{args.topic_prefix}{i}": args.receivers_per_topic for i in range(1, args.streams + 1)}

    # ensure subscriber counts are set from --receivers-per-topic when not provided
    for k in list(topic_map.keys()):
        if not isinstance(topic_map[k], int) or topic_map[k] == 0:
            topic_map[k] = int(args.receivers_per_topic)

    print("Topic map:", topic_map)

    processes = []  # list of (role, topic, idx, proc)
    pub_proc = None
    play_proc = None

    # prepare log handling
    log_dir = None
    if args.save_logs:
        log_dir = os.path.join(script_dir, "loadtest-logs")
        os.makedirs(log_dir, exist_ok=True)
    try:
        if args.spawn:
            # spawn a publisher per topic
            for idx, (tname, subs) in enumerate(topic_map.items()):
                pub_url = f"rtsp://{args.host}:{args.pub_port}/{tname}"
                ffmpeg_cmd = build_ffmpeg_cmd(ffmpeg, infile, pub_url, args.reencode, args.loop)
                print(f"Starting publisher for {tname}:")
                print(" ", " ".join(ffmpeg_cmd))
                if log_dir:
                    fn = os.path.join(log_dir, f"pub_{tname}.log")
                    fout = open(fn, "wb")
                    p = subprocess.Popen(ffmpeg_cmd, stdout=fout, stderr=subprocess.STDOUT)
                else:
                    p = subprocess.Popen(ffmpeg_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                processes.append(("pub", tname, 0, p))
                # spawn subscribers for this topic
                for si in range(0, int(subs)):
                    sub_url = f"rtsp://{args.host}:{args.sub_port}/{tname}"
                    sub_cmd = build_subscriber_cmd(ffmpeg, sub_url)
                    if log_dir:
                        sfn = os.path.join(log_dir, f"sub_{tname}_{si}.log")
                        sfout = open(sfn, "wb")
                        sp = subprocess.Popen(sub_cmd, stdout=sfout, stderr=subprocess.STDOUT)
                    else:
                        sp = subprocess.Popen(sub_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    processes.append(("sub", tname, si, sp))
                # stagger starts
                time.sleep(args.stagger_ms / 1000.0)
            # optionally start a single ffplay against the first topic if requested
            play_proc = None
            if args.play and ffplay and len(topic_map) > 0:
                first_topic = next(iter(topic_map.keys()))
                sub_url = f"rtsp://{args.host}:{args.sub_port}/{first_topic}"
                time.sleep(1.0)
                ffplay_cmd = build_ffplay_cmd(ffplay, sub_url)
                print("Starting player:")
                print(" ", " ".join(ffplay_cmd))
                if log_dir:
                    pfn = os.path.join(log_dir, f"ffplay_{first_topic}.log")
                    pf = open(pfn, "wb")
                    play_proc = subprocess.Popen(ffplay_cmd, stdout=pf, stderr=subprocess.STDOUT)
                else:
                    play_proc = subprocess.Popen(ffplay_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

            # wait until interrupted
            while True:
                time.sleep(0.5)
        else:
            # single publisher mode: pick first topic
            first = next(iter(topic_map.keys()))
            pub_url = f"rtsp://{args.host}:{args.pub_port}/{first}"
            sub_url = f"rtsp://{args.host}:{args.sub_port}/{first}"
            ffmpeg_cmd = build_ffmpeg_cmd(ffmpeg, infile, pub_url, args.reencode, args.loop)
            print("Starting publisher:")
            print(" ", " ".join(ffmpeg_cmd))
            pub_proc = subprocess.Popen(ffmpeg_cmd)
            play_proc = None
            if args.play and ffplay:
                time.sleep(1.0)
                ffplay_cmd = build_ffplay_cmd(ffplay, sub_url)
                print("Starting player:")
                print(" ", " ".join(ffplay_cmd))
                play_proc = subprocess.Popen(ffplay_cmd)

            while True:
                ret = pub_proc.poll()
                if ret is not None:
                    print(f"ffmpeg exited with code {ret}")
                    break
                time.sleep(0.5)

    except KeyboardInterrupt:
        print("Interrupted, terminating child processes...")
    finally:
        # terminate spawned processes
        for _, p in processes:
            if p is None:
                continue
            try:
                p.terminate()
            except Exception:
                pass
        if pub_proc is not None:
            try:
                pub_proc.terminate()
            except Exception:
                pass
        if play_proc is not None:
            try:
                play_proc.terminate()
            except Exception:
                pass
        time.sleep(0.5)
        # kill if still alive
        for _, p in processes:
            if p is None:
                continue
            if p.poll() is None:
                try:
                    p.kill()
                except Exception:
                    pass
        if pub_proc is not None and pub_proc.poll() is None:
            try:
                pub_proc.kill()
            except Exception:
                pass
        if play_proc is not None and play_proc.poll() is None:
            try:
                play_proc.kill()
            except Exception:
                pass


if __name__ == "__main__":
    main()
